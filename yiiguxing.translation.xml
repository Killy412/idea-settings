<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogHeight" value="429" />
    <option name="newTranslationDialogWidth" value="440" />
    <option name="newTranslationDialogX" value="612" />
    <option name="newTranslationDialogY" value="155" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="斐波那契&#10;" />
      <item value="斐波那" />
      <item value="斐波" />
      <item value="斐" />
      <item value="链表&#10;" />
      <item value="dummy&#10;" />
      <item value="Distributed implementation of Bloom filter based on Highway 128-bit hash." />
      <item value="Returns {@code true} if the element &lt;i&gt;might&lt;i&gt; have been put in this Bloom filter, {@code false} if this is &lt;i&gt;definitely&lt;i&gt; not the case." />
      <item value="See &quot;Less Hashing, Same Performance: Building a Better Bloom Filter&quot; by Adam Kirsch and Michael Mitzenmacher. The paper argues that this trick doesn't significantly deteriorate the performance of a Bloom filter (yet only needs two 32bit hash functions)." />
      <item value="Signifies that a public API (public class, method or field) is subject to incompatible changes, or even removal, in a future release. An API bearing this annotation is exempt from any compatibility guarantees made by its containing library. Note that the presence of this annotation implies nothing about the quality or performance of the API in question, only the fact that it is not &quot;API-frozen.&quot;" />
      <item value="funnel the funnel of T's that the constructed {@code BloomFilter} will use" />
      <item value="the desired false positive probability (must be positive and less than 1.0)" />
      <item value="expected" />
      <item value="拼接条件" />
      <item value="拼接" />
      <item value="Set the first row to retrieve. If not set, rows will be retrieved beginnning from row &lt;tt&gt;0&lt;tt&gt;. @param firstResult a row number, numbered from &lt;tt&gt;0&lt;tt&gt;" />
      <item value="下架" />
      <item value="下架人" />
      <item value="下架人&#10;" />
      <item value="ids for this class must be manually assigned before calling save()" />
      <item value="shelf" />
      <item value="下架&#10;" />
      <item value="tool" />
      <item value="protection" />
      <item value="Indicates one or more &lt;em&gt;component classes&lt;em&gt; to import &amp;mdash; typically" />
      <item value="A load balancer rule that filters out servers that: &lt;ul&gt; &lt;li&gt; are in circuit breaker tripped state due to consecutive connection or read failures, or&lt;li&gt; &lt;li&gt; have active connections that exceeds a configurable limit (default is Integer.MAX_VALUE).&lt;li&gt; &lt;ul&gt; The property to change this limit is &lt;pre&gt;{@code &lt;clientName&gt;.&lt;nameSpace&gt;.ActiveConnectionsLimit }&lt;pre&gt;" />
      <item value="The most well known and basic load balancing strategy, i.e. Round Robin Rule." />
      <item value="Given that {@link IRule} can be cascaded, this {@link RetryRule} class allows adding a retry logic to an existing Rule." />
      <item value="Supports preferentially calling the ribbon load balancing rules of the same cluster instance." />
      <item value="recommend" />
      <item value="the parameterized type of the destination Map object" />
      <item value="the parameterized type of the source Map object" />
      <item value="Rainbowify big files is disabled by default: File with line count &gt; 1000 will not rainbowify be default." />
      <item value="Should the registered urls be built with server.address or with hostname." />
      <item value="Circuit Breaker" />
      <item value="Protection" />
      <item value="Filter" />
      <item value="cost" />
      <item value="Balanced" />
      <item value="Factory class used to customize the retry functionality throughout Spring Cloud." />
      <item value="Specify whether {@code @Bean} methods should get proxied in order to enforce bean lifecycle behavior, e.g. to return shared singleton bean instances even in case of direct {@code @Bean} method calls in user code. This feature requires method interception, implemented through a runtime-generated CGLIB subclass which comes with limitations such as the configuration class and its methods not being allowed to declare {@code final}. &lt;p&gt;The default is {@code true}, allowing for 'inter-bean references' via direct method calls within the configuration class as well as for external calls to this configuration's {@code @Bean} methods, e.g. from another configuration class. If this is not needed since each of this particular configuration's {@code @Bean} methods is self-contained and designed as a plain factory method for container use, switch this flag to {@code false} in order to avoid CGLIB subclass processing. &lt;p&gt;Turning off bean method interception effectively processes {@code @Bean} methods individually like when declared on non-{@code @Configuration} classes, a.k.a. &quot;@Bean Lite Mode&quot; (see {@link Bean @Bean's javadoc}). It is therefore behaviorally equivalent to removing the {@code @Configuration} stereotype." />
      <item value="Acquires a permit from this semaphore, blocking until one is available, or the thread is {@linkplain Threadinterrupt interrupted}." />
      <item value="Walkthrough: 1. If read count nonzero or write count nonzero and owner is a different thread, fail. 2. If count would saturate, fail. (This can only happen if count is already nonzero.) 3. Otherwise, this thread is eligible for lock if it is either a reentrant acquire or queue policy allows it. If so, update state and set owner." />
      <item value="Release" />
      <item value="Decrements the count of the latch, releasing all waiting threads if the count reaches zero. &lt;p&gt;If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes. &lt;p&gt;If the current count equals zero then nothing happens." />
      <item value="Head of the wait queue, lazily initialized. Except for initialization, it is modified only via method setHead. Note: If head exists, its waitStatus is guaranteed not to be CANCELLED." />
      <item value="The synchronization state." />
      <item value="head" />
      <item value="tail" />
      <item value="ThreadLocalMap is a customized hash map suitable only for maintaining thread local values. No operations are exported outside of the ThreadLocal class. The class is package private to allow declaration of fields in class Thread. To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys. However, since reference queues are not used, stale entries are guaranteed to be removed only when the table starts running out of space." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="234" />
        <entry key="ENGLISH" value="235" />
        <entry key="IRISH" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="GREEK" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1615184333644" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200306000393838" />
      </app-key>
    </option>
    <option name="translateDocumentation" value="true" />
  </component>
</application>